@startuml login-sequence-diagram
!theme plain
title Diagrama de Secuencia - Login de Usuario

actor Cliente as C
participant "AuthController" as AC
participant "AuthService" as AS
participant "UsersService" as US
participant "TokensService" as TS
participant "AuthEmailService" as AES
participant "JwtService" as JWT
database "Base de Datos" as BD
participant "Servicio de Email\n(SMTP)" as EMAIL

note over C, EMAIL
    Flujo para el login de usuario en el sistema
    con validaciones, verificación de credenciales y generación de JWT
end note

C -> AC: POST /auth/login\n{LoginDto: email, password}
activate AC

AC -> AS: login(loginDto)
activate AS

note over AS
    Extraer credenciales:
    - email
    - password
end note

AS -> US: findByEmailWithPassword(email)
activate US
US -> BD: SELECT id, email, password, name, confirmed\nFROM user WHERE email = ?
activate BD
BD --> US: User | null
deactivate BD
US --> AS: user
deactivate US

alt user == null
    AS --> AC: UnauthorizedException\n"Usuario No Encontrado"
    AC --> C: HTTP 401\n"Usuario No Encontrado"
else user.confirmed == false
    note over AS
        Usuario no confirmado:
        Generar nuevo token y
        reenviar email de confirmación
    end note
    
    AS -> AS: generateToken()
    AS -> TS: create({token, userId})
    activate TS
    TS -> BD: INSERT INTO token\n(token, userId, createdAt, expiresAt)
    activate BD
    BD --> TS: Token creado
    deactivate BD
    TS --> AS: tokenRecord
    deactivate TS
    
    AS -> AES: sendConfirmationEmail({email, name, token})
    activate AES
    AES -> EMAIL: Enviar email de confirmación
    activate EMAIL
    EMAIL --> AES: Email enviado
    deactivate EMAIL
    AES --> AS: Email confirmación enviado
    deactivate AES
    
    AS --> AC: UnauthorizedException\n"Tu cuenta no está confirmada.\nHemos enviado un nuevo código de verificación a tu email."
    AC --> C: HTTP 401\nMensaje de cuenta no confirmada
else Usuario válido y confirmado
    
    note over AS
        Verificar contraseña:
        Comparar password en texto plano
        con hash almacenado usando bcrypt
    end note
    
    AS -> AS: checkPassword(password, user.password)
    
    alt Password incorrecto
        AS --> AC: UnauthorizedException\n"Password Incorrecto"
        AC --> C: HTTP 401\n"Password Incorrecto"
    else Password correcto
        
        note over AS
            Generar JWT Token:
            Payload: {id: user.id}
            Configuración: expiresIn '1d'
        end note
        
        AS -> JWT: sign({id: user.id})
        activate JWT
        
        note over JWT
            Crear JWT con:
            - Secret key del entorno
            - Expiración: 1 día
            - Payload: ID del usuario
        end note
        
        JWT --> AS: jwtToken
        deactivate JWT
        
        AS --> AC: jwtToken
        AC --> C: HTTP 200\n{token: "eyJ..."}
    end
end

deactivate AS
deactivate AC

note over C, EMAIL
    El cliente debe incluir el JWT token recibido
    en el header Authorization: Bearer <token>
    para acceder a endpoints protegidos
end note

@enduml