@startuml Forgot Password Sequence Diagram

title Sistema de Autenticación - Diagrama de Secuencia: RECUPERACIÓN DE CONTRASEÑA

actor Cliente as C
participant "AuthController" as AC
participant "AuthService" as AS
participant "UsersService" as US
participant "TokensService" as TS
participant "AuthEmailService" as AES
participant "MailerService" as MS
participant "Token Utils" as TU
database "Database" as DB

== Proceso de Solicitar Reset de Contraseña ==

C -> AC: POST /auth/forgot-password
note right of C: ForgotPasswordDto:\n- email

activate AC
AC -> AS: forgotPassword(forgotPasswordDto)
note right of AC: Invoca el método\nforgotPassword del AuthService

activate AS
AS -> AS: Extraer email de\nforgotPasswordDto
note over AS: const { email } = forgotPasswordDto

=== Verificar si el usuario existe ===
AS -> US: findByEmail(email)
note right of AS: Busca usuario por email\nsin importar estado de confirmación
activate US
US -> DB: SELECT * FROM users\nWHERE email = :email
activate DB
DB --> US: Retorna usuario o null\nsi no existe
deactivate DB
US --> AS: user | null
deactivate US

alt Usuario no existe
    note over AS: user === null
    AS --> AC: NotFoundException(\n"El Usuario no existe")
    AC --> C: HTTP 404\n{"message": "El Usuario no existe"}
    note right of C: Email no registrado\nen el sistema
    
else Usuario existe
    note over AS: user encontrado\n(confirmado o no confirmado)
    
    === Generar token de reset ===
    AS -> TU: generateToken()
    note right of AS: Genera token aleatorio\nde 6 dígitos para reset
    activate TU
    TU -> TU: Math.floor(Math.random() * 900000) + 100000
    TU --> AS: tokenValue (string de 6 dígitos)
    deactivate TU
    
    === Crear y guardar token en base de datos ===
    AS -> TS: create({token: tokenValue, userId: user.id})
    note right of AS: Crea token de reset\nasociado al usuario
    activate TS
    TS -> DB: INSERT INTO tokens\n(token, user_id, created_at)\nVALUES (:token, :userId, NOW())
    activate DB
    
    note over DB: Token para reset de password\n(puede coexistir con tokens\nde confirmación)
    
    DB --> TS: Token creado\nsuccessfully
    deactivate DB
    TS --> AS: tokenEntity
    deactivate TS
    
    === Enviar email con instrucciones de reset ===
    AS -> AES: sendPasswordResetToken({\nemail: user.email,\nname: user.name,\ntoken: tokenValue})
    note right of AS: Envía email específico\npara reset de password
    activate AES
    
    AES -> AES: Construir contenido HTML\npara reset de password
    note over AES: HTML incluye:\n- Saludo personalizado\n- Enlace: /auth/new-password\n- Token de 6 dígitos\n- Instrucciones claras\n- Tiempo de expiración (10 min)
    
    AES -> MS: sendMail({\nto: user.email,\nsubject: "UpTask - Reestablece tu password",\nhtml: resetPasswordHTML\n})
    activate MS
    MS -> MS: Configurar SMTP\ny enviar email de reset
    MS --> AES: Email de reset enviado\nsuccessfully
    deactivate MS
    AES --> AS: void
    deactivate AES
    
    === Respuesta exitosa ===
    AS --> AC: {message: "Revisa tu email para instrucciones"}
    AC --> C: HTTP 200\n{"message": "Revisa tu email para instrucciones"}
    note right of C: Email de reset enviado\nRevisar bandeja de entrada
end

deactivate AS
deactivate AC

== Flujo Completo: Del Email al Cambio de Password ==

note over C, DB
**Pasos siguientes después del email:**

1. Usuario recibe email con token
2. Click en enlace → /auth/new-password  
3. Frontend: POST /auth/validate-token {token}
4. Si válido → Mostrar formulario nuevo password
5. Frontend: POST /auth/update-password {token, password}
6. Password actualizado → Token eliminado
end note

== Validación del Token (Paso 3) ==

C -> AC: POST /auth/validate-token
note right of C: ValidateTokenDto:\n- token

AC -> AS: validateToken(validateTokenDto)
activate AS

AS -> TS: findByToken(token)
activate TS
TS -> DB: SELECT * FROM tokens\nWHERE token = :token
DB --> TS: token | null
TS --> AS: tokenExists | null
deactivate TS

alt Token no válido
    AS --> AC: NotFoundException("Token no válido")
    AC --> C: HTTP 404\n{"message": "Token no válido"}
    note right of C: Token incorrecto,\nexpirado o ya usado
else Token válido
    AS --> AC: {message: "Token válido, Define tu nuevo password"}
    AC --> C: HTTP 200\n{"message": "Token válido..."}
    note right of C: Mostrar formulario\nde nuevo password
end
deactivate AS

== Actualización del Password (Paso 5) ==

C -> AC: POST /auth/update-password
note right of C: UpdatePasswordWithTokenDto:\n- token\n- password

AC -> AS: updatePasswordWithToken(updatePasswordWithTokenDto)
activate AS

AS -> TS: findByTokenWithUser(token)
activate TS
TS -> DB: SELECT tokens.*, users.*\nFROM tokens\nJOIN users ON tokens.user_id = users.id\nWHERE tokens.token = :token
DB --> TS: tokenWithUser | null
TS --> AS: tokenExists | null
deactivate TS

alt Token no válido
    AS --> AC: NotFoundException("Token no válido")
    AC --> C: HTTP 404\n{"message": "Token no válido"}
else Token válido
    AS -> AS: user = tokenExists.user
    AS -> AS: hashPassword(password)
    note over AS: Encripta nueva contraseña\ncon bcrypt
    
    AS -> AS: user.password = hashedPassword
    AS -> US: save(user)
    activate US
    US -> DB: UPDATE users\nSET password = :hashedPassword,\nupdated_at = NOW()\nWHERE id = :userId
    DB --> US: Password actualizado
    US --> AS: void
    deactivate US
    
    AS -> TS: remove(tokenExists.id)
    activate TS
    TS -> DB: DELETE FROM tokens\nWHERE id = :tokenId
    DB --> TS: Token eliminado\n(un solo uso)
    TS --> AS: void
    deactivate TS
    
    AS --> AC: {message: "El password se modificó correctamente"}
    AC --> C: HTTP 200\n{"message": "El password se modificó correctamente"}
    note right of C: Password cambiado\nPuede hacer login normal
end
deactivate AS

== Casos de Uso y Consideraciones ==

note over C, DB
**Casos de uso típicos:**
• Usuario olvidó su contraseña
• Sospecha de cuenta comprometida  
• Cambio preventivo de seguridad
• Password muy antiguo

**Diferencias con confirmAccount:**
• Email template diferente
• Enlace diferente (/new-password vs /confirm-account)
• Funciona con cuentas confirmadas y no confirmadas
• Modifica password en lugar de confirmed flag

**Seguridad implementada:**
• Token de un solo uso
• Validación de existencia del usuario
• Hash seguro de la nueva contraseña
• Eliminación inmediata del token usado
• Expiración temporal del token
end note

@enduml