@startuml Sistema de Autenticación - Diagramas de Secuencia

title Diagramas de Secuencia del Sistema de Autenticación

' ============================================
' DIAGRAMA 1: REGISTRO DE USUARIO
' ============================================

title Registro de Usuario

actor Cliente as C
participant AuthController as AC
participant AuthService as AS
participant UsersService as US
participant TokensService as TS
participant AuthEmailService as AES
participant MailerService as MS
database Database as DB

== Registro de Usuario ==
C -> AC: POST /auth/create-account\n(RegisterDto)
AC -> AS: register(registerDto)

AS -> US: findByEmail(email)
US -> DB: SELECT user WHERE email
alt Usuario ya existe
  DB --> US: Usuario encontrado
  US --> AS: Usuario existente
  AS --> AC: BadRequestException("Usuario ya registrado")
  AC --> C: 400 Bad Request
else Usuario no existe
  DB --> US: null
  US --> AS: null
  
  AS -> AS: hashPassword(password)
  AS -> US: create(userData)
  US -> DB: INSERT INTO users
  DB --> US: Usuario creado
  US --> AS: user
  
  AS -> AS: generateToken()
  AS -> TS: create({token, userId})
  TS -> DB: INSERT INTO tokens
  DB --> TS: Token creado
  TS --> AS: tokenEntity
  
  AS -> AES: sendConfirmationEmail({email, name, token})
  AES -> MS: sendMail(emailData)
  MS --> AES: Email enviado
  AES --> AS: void
  
  AS --> AC: {message: "Cuenta creada..."}
  AC --> C: 201 Created
end

@enduml

@startuml

' ============================================
' DIAGRAMA 2: CONFIRMACIÓN DE CUENTA
' ============================================

title Confirmación de Cuenta

actor Cliente as C
participant AuthController as AC
participant AuthService as AS
participant TokensService as TS
participant UsersService as US
database Database as DB

== Confirmación de Cuenta ==
C -> AC: POST /auth/confirm-account\n(ConfirmAccountDto)
AC -> AS: confirmAccount(confirmAccountDto)

AS -> TS: findByTokenWithUser(token)
TS -> DB: SELECT token WITH user WHERE token
alt Token no válido
  DB --> TS: null
  TS --> AS: null
  AS --> AC: NotFoundException("Token no válido")
  AC --> C: 404 Not Found
else Token válido
  DB --> TS: tokenWithUser
  TS --> AS: tokenExists
  
  AS -> AS: user.confirmed = true
  AS -> US: save(user)
  US -> DB: UPDATE users SET confirmed = true
  DB --> US: Usuario actualizado
  US --> AS: void
  
  AS -> TS: remove(tokenExists.id)
  TS -> DB: DELETE FROM tokens WHERE id
  DB --> TS: Token eliminado
  TS --> AS: void
  
  AS --> AC: {message: "Cuenta confirmada correctamente"}
  AC --> C: 200 OK
end

@enduml

@startuml

' ============================================
' DIAGRAMA 3: LOGIN
' ============================================

title Login de Usuario

actor Cliente as C
participant AuthController as AC
participant AuthService as AS
participant UsersService as US
participant TokensService as TS
participant AuthEmailService as AES
participant JwtUtilService as JUS
database Database as DB

== Login de Usuario ==
C -> AC: POST /auth/login\n(LoginDto)
AC -> AS: login(loginDto)

AS -> US: findByEmailWithPassword(email)
US -> DB: SELECT user WITH password WHERE email
alt Usuario no encontrado
  DB --> US: null
  US --> AS: null
  AS --> AC: UnauthorizedException("Usuario No Encontrado")
  AC --> C: 401 Unauthorized
else Usuario encontrado
  DB --> US: user
  US --> AS: user
  
  alt Cuenta no confirmada
    AS -> AS: generateToken()
    AS -> TS: create({token, userId})
    TS -> DB: INSERT INTO tokens
    DB --> TS: Token creado
    TS --> AS: void
    
    AS -> AES: sendConfirmationEmail({email, name, token})
    AES --> AS: void
    AS --> AC: UnauthorizedException("Cuenta no confirmada...")
    AC --> C: 401 Unauthorized
  else Cuenta confirmada
    AS -> AS: checkPassword(password, user.password)
    alt Password incorrecto
      AS --> AC: UnauthorizedException("Password Incorrecto")
      AC --> C: 401 Unauthorized
    else Password correcto
      AS -> JUS: generateJWT({id: user.id})
      JUS --> AS: jwtToken
      AS --> AC: {token: jwtToken}
      AC --> C: 200 OK
    end
  end
end

@enduml

@startuml

' ============================================
' DIAGRAMA 4: RECUPERACIÓN DE PASSWORD
' ============================================

title Recuperación de Password

actor Cliente as C
participant AuthController as AC
participant AuthService as AS
participant UsersService as US
participant TokensService as TS
participant AuthEmailService as AES
database Database as DB

== Solicitar Reset de Password ==
C -> AC: POST /auth/forgot-password\n(ForgotPasswordDto)
AC -> AS: forgotPassword(forgotPasswordDto)

AS -> US: findByEmail(email)
US -> DB: SELECT user WHERE email
alt Usuario no existe
  DB --> US: null
  US --> AS: null
  AS --> AC: NotFoundException("Usuario no existe")
  AC --> C: 404 Not Found
else Usuario existe
  DB --> US: user
  US --> AS: user
  
  AS -> AS: generateToken()
  AS -> TS: create({token, userId})
  TS -> DB: INSERT INTO tokens
  DB --> TS: Token creado
  TS --> AS: void
  
  AS -> AES: sendPasswordResetToken({email, name, token})
  AES --> AS: void
  AS --> AC: {message: "Revisa tu email..."}
  AC --> C: 200 OK
end

== Validar Token de Reset ==
C -> AC: POST /auth/validate-token\n(ValidateTokenDto)
AC -> AS: validateToken(validateTokenDto)

AS -> TS: findByToken(token)
TS -> DB: SELECT token WHERE token
alt Token no válido
  DB --> TS: null
  TS --> AS: null
  AS --> AC: NotFoundException("Token no válido")
  AC --> C: 404 Not Found
else Token válido
  DB --> TS: tokenExists
  TS --> AS: tokenExists
  AS --> AC: {message: "Token válido..."}
  AC --> C: 200 OK
end

== Actualizar Password con Token ==
C -> AC: POST /auth/update-password\n(UpdatePasswordWithTokenDto)
AC -> AS: updatePasswordWithToken(updatePasswordWithTokenDto)

AS -> TS: findByTokenWithUser(token)
TS -> DB: SELECT token WITH user WHERE token
alt Token no válido
  DB --> TS: null
  TS --> AS: null
  AS --> AC: NotFoundException("Token no válido")
  AC --> C: 404 Not Found
else Token válido
  DB --> TS: tokenWithUser
  TS --> AS: tokenExists
  
  AS -> AS: hashPassword(password)
  AS -> AS: user.password = hashedPassword
  AS -> US: save(user)
  US -> DB: UPDATE users SET password
  DB --> US: Usuario actualizado
  US --> AS: void
  
  AS -> TS: remove(tokenExists.id)
  TS -> DB: DELETE FROM tokens WHERE id
  DB --> TS: Token eliminado
  TS --> AS: void
  
  AS --> AC: {message: "Password modificado correctamente"}
  AC --> C: 200 OK
end

@enduml

@startuml

' ============================================
' DIAGRAMA 5: OPERACIONES AUTENTICADAS
' ============================================

title Operaciones con Autenticación

actor Cliente as C
participant AuthController as AC
participant AuthGuard as AG
participant JwtService as JS
participant AuthService as AS
participant UsersService as US
database Database as DB

== Obtener Perfil de Usuario ==
C -> AC: GET /auth/user\nAuthorization: Bearer <token>
AC -> AG: canActivate()
AG -> AG: extractTokenFromHeader(request)
alt Token no presente
  AG --> AC: UnauthorizedException()
  AC --> C: 401 Unauthorized
else Token presente
  AG -> JS: verifyAsync(token)
  alt Token inválido
    JS --> AG: Error
    AG --> AC: UnauthorizedException()
    AC --> C: 401 Unauthorized
  else Token válido
    JS --> AG: payload
    AG -> AG: request.user = payload
    AG --> AC: true (permite acceso)
    
    AC -> AS: getUser(req.user.id)
    AS -> US: findOne(userId)
    US -> DB: SELECT user WHERE id
    DB --> US: user
    US --> AS: user
    AS --> AC: user
    AC --> C: 200 OK + userData
  end
end

== Actualizar Perfil ==
C -> AC: POST /auth/profile\n(UpdateProfileDto)\nAuthorization: Bearer <token>
AC -> AG: canActivate()
note over AG: Mismo flujo de validación que arriba
AG --> AC: true

AC -> AS: updateProfile(req.user.id, updateProfileDto)
AS -> US: findByEmail(email)
US -> DB: SELECT user WHERE email
alt Email ya en uso por otro usuario
  DB --> US: otherUser
  US --> AS: otherUser
  AS --> AC: BadRequestException("Email ya en uso")
  AC --> C: 400 Bad Request
else Email disponible
  AS -> US: findOne(userId)
  US -> DB: SELECT user WHERE id
  DB --> US: currentUser
  US --> AS: user
  
  AS -> AS: user.name = name\nuser.email = email.toLowerCase()
  AS -> US: save(user)
  US -> DB: UPDATE users SET name, email
  DB --> US: Usuario actualizado
  US --> AS: void
  AS --> AC: {message: "Perfil actualizado"}
  AC --> C: 200 OK
end

== Cambiar Password ==
C -> AC: POST /auth/update-password\n(UpdateCurrentUserPasswordDto)\nAuthorization: Bearer <token>
AC -> AG: canActivate()
note over AG: Mismo flujo de validación
AG --> AC: true

AC -> AS: updateCurrentUserPassword(req.user.id, updateCurrentUserPasswordDto)
AS -> US: findByIdWithPassword(userId)
US -> DB: SELECT user WITH password WHERE id
DB --> US: user
US --> AS: user

AS -> AS: checkPassword(current_password, user.password)
alt Password actual incorrecto
  AS --> AC: BadRequestException("Password actual incorrecto")
  AC --> C: 400 Bad Request
else Password actual correcto
  AS -> AS: hashPassword(password)
  AS -> AS: user.password = hashedPassword
  AS -> US: save(user)
  US -> DB: UPDATE users SET password
  DB --> US: Usuario actualizado
  US --> AS: void
  AS --> AC: {message: "Password modificado"}
  AC --> C: 200 OK
end

@enduml

@startuml

' ============================================
' DIAGRAMA 6: SOLICITAR NUEVO CÓDIGO DE CONFIRMACIÓN
' ============================================

title Solicitar Nuevo Código de Confirmación

actor Cliente as C
participant AuthController as AC
participant AuthService as AS
participant UsersService as US
participant TokensService as TS
participant AuthEmailService as AES
database Database as DB

== Solicitar Nuevo Código ==
C -> AC: POST /auth/request-code\n(RequestConfirmationCodeDto)
AC -> AS: requestConfirmationCode(requestConfirmationCodeDto)

AS -> US: findByEmail(email)
US -> DB: SELECT user WHERE email
alt Usuario no existe
  DB --> US: null
  US --> AS: null
  AS --> AC: NotFoundException("Usuario no existe")
  AC --> C: 404 Not Found
else Usuario existe
  DB --> US: user
  US --> AS: user
  
  alt Usuario ya confirmado
    AS --> AC: BadRequestException("Usuario ya confirmado")
    AC --> C: 400 Bad Request
  else Usuario no confirmado
    AS -> AS: generateToken()
    AS -> TS: create({token, userId})
    TS -> DB: INSERT INTO tokens
    DB --> TS: Token creado
    TS --> AS: void
    
    AS -> AES: sendConfirmationEmail({email, name, token})
    AES --> AS: void
    AS --> AC: {message: "Nuevo token enviado"}
    AC --> C: 200 OK
  end
end

@enduml

@startuml

' ============================================
' DIAGRAMA 7: VERIFICAR PASSWORD
' ============================================

title Verificar Password

actor Cliente as C
participant AuthController as AC
participant AuthGuard as AG
participant AuthService as AS
participant UsersService as US
database Database as DB

== Verificar Password ==
C -> AC: POST /auth/check-password\n(CheckPasswordDto)\nAuthorization: Bearer <token>
AC -> AG: canActivate()
note over AG: Validación de token JWT
AG --> AC: true

AC -> AS: checkPassword(req.user.id, checkPasswordDto)
AS -> US: findByIdWithPassword(userId)
US -> DB: SELECT user WITH password WHERE id
DB --> US: user
US --> AS: user

AS -> AS: checkPassword(password, user.password)
alt Password incorrecto
  AS --> AC: BadRequestException("Password Incorrecto")
  AC --> C: 400 Bad Request
else Password correcto
  AS --> AC: {message: "Password Correcto"}
  AC --> C: 200 OK
end

@enduml